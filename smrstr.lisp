(declaim (optimize (speed 3) (safety 0) (debug 0)))

(defvar *empty* #())

(defmacro with-gensyms (syms &body body)
  `(let (,@(mapcar (lambda (s) `(,s (gensym))) syms))
     ,@body))

(defmacro for ((var from to &optional result) &body body)
  (with-gensyms (%from %to)
    `(let ((,%from ,from) (,%to ,to))
       (do ((,var ,%from (1+ ,var)))
           ((>= ,var ,%to) ,result)
           (declare (fixnum ,var ,%from ,%to))
           ,@body))))

(defun read-n-numbers (n)
  (let* ((line (read-line))
         (str (make-string-input-stream line))
         (result (make-array n :element-type 'fixnum)))
    (declare (string line) (stream str) ((array fixnum) result))
    (for (i 0 n result) 
      (setf (aref result i) (read str)))))

(defun calculate-divisor (arr)
  (let ((div 0))
    (declare (number div) (array arr))
    (for (i 0 (length arr) div)
      (incf div (log (aref arr i) 2)))))

(defun get-ans (x div)
  (declare (fixnum x) (number div))
  (round (expt 2 (- (log x 2) div))))


(defun run-case ()
  (let* ((n-and-q (read-n-numbers 2))
         (d (read-n-numbers (aref n-and-q 0)))
         (div (calculate-divisor d))
         (xs (read-n-numbers (aref n-and-q 1)))
         (ans (make-array (aref n-and-q 1) :element-type 'fixnum)))
    (declare (array n-and-q d xs ans))
    (for (i 0 (length ans) ans)
      (setf (aref ans i) (get-ans (aref xs i) div)))))

(defun print-array (arr &key (str *standard-output*) (size (length arr)))
  (declare (array arr) (stream str) (fixnum size))
  (let ((last-space (1- size)))
    (for (i 0 size)
      (format str "~A" (aref arr i))
      (when (< i last-space)
        (format str " ")))
    (format str "~%")))

(defun main ()
  (let* ((tests (read))
         (answers (make-array tests :element-type '(array fixnum))))
    (declare (fixnum tests))
    (for (i 0 tests)
      (setf (aref answers i) (run-case)))
    (for (i 0 tests)
      (print-array (aref answers i)))))

(main)
