(declaim (optimize (safety 0) (debug 0) (speed 3)))

(defun to-array (n &optional (d (1+ (floor (log n 10)))))
  (declare (integer n))
  (let ((vec (make-array d :element-type 'fixnum))
        (total (1+ (floor (log n 10)))))
    (dotimes (i d vec)
      (setf (aref vec i) (floor (mod n (expt 10 (- total i)))
                                (expt 10 (- total 1 i)))))))
(defun from-array (narr)
  (declare ((array fixnum) narr))
  (let ((sum 0)
        (l (length narr)))
    (declare ((array fixnum) narr)
             (integer sum l))
    (dotimes (i l sum)
      (incf sum (* (aref narr i) (expt 10 (- l i 1)))))))

(defun next (n)
  (declare (integer n))
  (when (< n 10)
    (return-from next n))
  (let* ((num (to-array n))
         (half (/ (length num) 2))
         (lidx (floor half))
         (ridx (ceiling half))
         (l (from-array (subseq num 0 ridx)))
         (l-inv (from-array (nreverse (subseq num 0 lidx))))
         (r (from-array (subseq num ridx))))
    (declare (integer half lidx ridx l l-inv r)
             ((simple-array fixnum) num))
    (if (>= r l-inv)
        (format t "~A~A~%" (1+ l)
                (from-array (nreverse (to-array (1+ l) lidx))))
        (format t "~A~A~%" l l-inv))))

(declaim (inline to-array from-array next))

(defun main ()
  (dotimes (_ (read))
    (next (read))))

; (time (main))

(next 100001321)
